/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.uweeisele.kafka.metrics.reporter.otel.internal.kafka;

import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.instrumentation.api.internal.GuardedBy;
import net.uweeisele.kafka.metrics.reporter.otel.internal.CaseType;
import net.uweeisele.kafka.metrics.reporter.otel.internal.Context;
import org.apache.kafka.common.MetricName;
import org.apache.kafka.common.config.ConfigException;
import org.apache.kafka.common.metrics.KafkaMetric;
import org.apache.kafka.common.metrics.Measurable;
import org.apache.kafka.common.metrics.MetricsContext;
import org.apache.kafka.common.metrics.MetricsReporter;
import org.apache.kafka.common.metrics.stats.CumulativeSum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.*;

// see https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/kafka/kafka-clients/kafka-clients-common/library/src/main/java/io/opentelemetry/instrumentation/kafka/internal/OpenTelemetryMetricsReporter.java
public class OtelKafkaMetricsReporter implements MetricsReporter {

    private static final Logger log = LoggerFactory.getLogger(OtelKafkaMetricsReporter.class);

    private final Meter meter;
    private final InstrumentDescriptor.Builder descriptorBuilder;

    private final Object lock = new Object();
    @GuardedBy("lock")
    private final Map<MetricName, AutoCloseable> registeredObservables = new HashMap<>();

    public OtelKafkaMetricsReporter(Meter meter, Context context) {
        this(meter, InstrumentDescriptor.builder(context).withNameManipulator(CaseType.CAMEL_CASE.getManipulator().andThen(CaseType.FIRST_UPPER_CASE.getManipulator())));
    }

    OtelKafkaMetricsReporter(Meter meter, InstrumentDescriptor.Builder descriptorBuilder) {
        this.meter = meter;
        this.descriptorBuilder = descriptorBuilder;
    }

    @Override
    public void configure(Map<String, ?> configs) {

    }

    @Override
    public void contextChange(MetricsContext metricsContext) {

    }

    @Override
    public void init(List<KafkaMetric> metrics) {
        metrics.forEach(this::metricChange);
    }

    @Override
    public void metricChange(KafkaMetric metric) {
        log.trace("Adding instruments for Kafka metrics: {}", metric.metricName());
        InstrumentDescriptor descriptor = descriptorBuilder.build(metric.metricName());
        AutoCloseable observable = null;
        Measurable measurable = getMeasurable(metric);
        if (measurable instanceof CumulativeSum) {
            observable = descriptor.withSuffix(getStatType(measurable))
                    .register(d -> meter
                            .counterBuilder(d.getName())
                            .ofDoubles()
                            .setDescription(d.getDescription())
                            .buildWithCallback(o -> o.record(toDouble(metric.metricValue()), d.getAttributes())));
        } else if (metric.metricValue() instanceof Number) {
            observable = descriptor.withSuffix(getStatType(measurable))
                    .register(d -> meter
                            .gaugeBuilder(d.getName())
                            .setDescription(d.getDescription())
                            .buildWithCallback(o -> o.record(toDouble(metric.metricValue()), d.getAttributes())));
        }

        if (observable != null) {
            synchronized (lock) {
                AutoCloseable removedObservable = registeredObservables.put(metric.metricName(), observable);
                if (removedObservable != null) {
                    log.trace("Replacing instruments of Kafka metric: {}", metric.metricName());
                    closeObservable(removedObservable);
                } else {
                    log.trace("Adding instruments of Kafka metric: {}", metric.metricName());
                }
            }
        }
    }

    @Override
    public void metricRemoval(KafkaMetric metric) {
        synchronized (lock) {
            AutoCloseable removedObservable = registeredObservables.remove(metric.metricName());
            if (removedObservable != null) {
                log.trace("Removing instruments of Kafka metric: {}", metric.metricName());
                closeObservable(removedObservable);
            }
        }
    }

    @Override
    public void close() {
        synchronized (lock) {
            for (Iterator<AutoCloseable> it = registeredObservables.values().iterator(); it.hasNext(); ) {
                closeObservable(it.next());
                it.remove();
            }
        }
    }

    @Override
    public Set<String> reconfigurableConfigs() {
        return MetricsReporter.super.reconfigurableConfigs();
    }

    @Override
    public void validateReconfiguration(Map<String, ?> configs) throws ConfigException {
        MetricsReporter.super.validateReconfiguration(configs);
    }

    @Override
    public void reconfigure(Map<String, ?> configs) {
        MetricsReporter.super.reconfigure(configs);
    }

    @Nullable
    private static Measurable getMeasurable(KafkaMetric kafkaMetric) {
        try {
            return kafkaMetric.measurable();
        } catch (IllegalStateException e) {
            return null;
        }
    }

    private static String getStatType(Measurable measurable) {
        if (measurable == null || measurable.getClass().getSimpleName().isEmpty() || measurable.getClass().getSimpleName().contains("$")) {
            return "";
        }
        return measurable.getClass().getSimpleName().replace("Cumulative", "");
    }

    private Double toDouble(Object value) {
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return null;
    }

    private void closeObservable(AutoCloseable observable) {
        try {
            observable.close();
        } catch (Exception e) {
            log.warn("Error occurred closing observable {}", observable, e);
        }
    }

}
